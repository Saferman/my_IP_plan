### 阶乘计算

举个例子，我们来计算阶乘 `n! = 1 * 2 * 3 * ... * n`

```python
#不使用递归的方法：
n=4      #求4的阶乘
result=1
i=1
while i<=4:
    result=result*i
    i+=1

print(result)

#使用递归的方法：
def test1(n):#定义函数来计算数字n的阶乘
    if n==1:
        return 1
    return n * test1(n-1)

print(test1(5))
#1在函数的内部调用自己本身
#2递归函数本质是一个方法的循环调用，注意：有可能出现死循环
#3一定要定义递归的边界(什么时候退出循环)

```

### 递归函数的另一个案例是斐波纳契数列

斐波纳契数列：1，1，2，3，5，8，13。。。（该数列中，有n个数字，从第三个数字开始：数值 =前一个数字 + 前面一个数字）

即，n=(n-2)+(n-1)

```python
def get_num(n):#获取斐波拉契数列中第n个数字的值
    if n==1 or n==2:
        return 1
    return get_num(n-1) + get_num(n-2)

#把获取的斐波拉契数字存放到列表中
nums=[]
for i in range(1,21):
    nums.append(get_num(i))#get_num获得一个斐波拉契数字

print(nums)
```

### 实例任务

os模块运用：

- os.path.isdir 判断是否是目录
- os.listdir  *获取当前目录的所有文件（包括文件夹）*

任务：用递归实现遍历目录下的所有文件名（存到一个列表里面）



答案：

```python
import os
path = r'文件路径'
 
def func(path):
    # 创建一个文件列表以存储文件名
    files_list = []
    # 获取当前目录的所有文件（包括文件夹）
    files = os.listdir(path)
 
    # 获取当前目录的所有文件（包括文件夹）
    for i in files:
        # 判断当前对象是文件or文件夹
        if os.path.isdir(path+os.sep+i):
            # 是文件夹，则把文件夹的名字添加进目录中，得到新路径
            new_path = path+os.sep+i
            # 然后传入新路径递归执行函数
            files_list = func(new_path)+files_list
        else:
            # 是文件，直接把文件名添加进入文件列表
            files_list.append(i)
    # 递归结束，返回文件列表                  
    return files_list
 

files_list = func(path)
for i in files_list:
    print(i)
```

### 课后：

汉诺塔问题是一个经典的递归问题，它的目标是将一个塔上的所有盘子从一个柱子移动到另一个柱子，同时满足以下规则：

1. 每次只能移动一个盘子。
2. 盘子只能从顶部移动到另一个柱子的顶部。
3. 任何时候，较大的盘子不能放在较小的盘子上面。

```python
def hanoi(n, source, target, auxiliary):
    """
    汉诺塔递归函数
    :param n: 盘子的数量
    :param source: 源柱子（起始柱子）
    :param target: 目标柱子（最终要移动到的柱子）
    :param auxiliary: 辅助柱子（用于中转的柱子）
    """
    if n == 1:
        # 如果只有一个盘子，直接从源柱子移动到目标柱子
        print(f"Move disk 1 from {source} to {target}")
    else:
        # 将上面的 n-1 个盘子从源柱子移动到辅助柱子
        hanoi(n - 1, source, auxiliary, target)
        # 将最大的盘子从源柱子移动到目标柱子
        print(f"Move disk {n} from {source} to {target}")
        # 将辅助柱子上的 n-1 个盘子移动到目标柱子
        hanoi(n - 1, auxiliary, target, source)

# 示例：移动3个盘子
hanoi(3, 'A', 'C', 'B')
```

```python
def hanoi(n, x, y, z):
    if n == 1:
        print(x, '-->', z)  # 如果只有 1 层，直接将金片从 x 移动到 z
    else:
        hanoi(n-1, x, z, y) # 将 x 上的 n-1 个金片移动到 y
        print(x, '-->', z)  # 将最底下的金片从 x 移动到 z
        hanoi(n-1, y, x, z) # 将 y 上的 n-1 个金片移动到 z
    
n = int(input('请输入汉诺塔的层数：'))
hanoi(n, 'A', 'B', 'C')
```

